<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var rank = 3;
   string[] tName = ["i", "u", "f"];
   string[] types16 = ["short", "ushort", "Half"];
   string[] types32 = ["int", "uint", "float"];
   string[] types64 = ["long", "ulong", "double"];

   (int, string[])[] types = [(16, types16), (32, types32), (64, types64)];

   (int, string)[] cis = [(0, "x"), (1, "y"), (2, "z"), (3, "w")];
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static DualDrill.Mathematics.DMath;

namespace DualDrill.Mathematics;

<# foreach(var (bw, ts) in types) { #>
// <#= bw #>-bit scalar vec types
<#
	if(4 * bw < 64) {
		continue;
	}
	foreach(var (n, t) in tName.Zip(ts, (a, b) => (a, b))) 
	{
		
		if(bw == 16 && n == "f") {
			continue;
		}
		var name = $"vec{rank}{n}";
		var dataTypeName = $"Vector{4 * bw}";
		var stn = name + bw;
#>

public partial struct <#= name #><#= bw #> {
	internal <#= dataTypeName #><<#= t #>> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static <#= dataTypeName #><<#= t #>> CreateData(<#= t #> x, <#= t #> y, <#= t #> z) {
		return <#= dataTypeName #>.Create(x, y, z, default(<#= t #>));
	}

<# foreach(var (idx, com) in cis.Take(rank)) { #>
	public <#= t #> <#= com #> {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[<#= idx #>];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(<# if(idx == 0) { #>value<# } else { #>Data[0]<# } #>, <# if(idx == 1) { #>value<# } else { #>Data[1]<# } #>, <# if(idx == 2) { #>value<# } else { #>Data[2]<# } #>);
		}
	}
<# } #>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator -(<#= stn #> v) => new() { Data = - v.Data };

<# foreach(var op in (string [])[ "+", "-", "*", "/", "&", "|", "^" ]) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator <#= op #> (<#= stn #> l, <#= stn #> r) => new() { Data = l.Data <#= op #> r.Data };

<# } #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator %(<#= stn #> l, <#= stn #> r) => new() { Data = <#= dataTypeName #>.Create((<#= t #>)(l.x % r.x), (<#= t #>)(l.y % r.y), (<#= t #>)(l.z % r.z), default(<#= t #>)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec3(<#= t #> x, <#= t #> y, <#= t #> z) => new() { Data =  <#= name #><#= bw #>.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec3(<#= t #> e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec3(<#= t #> e, vec2<#= n #><#= bw #> v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec3(vec2<#= n #><#= bw #> v, <#= t #> e) => vec3(v.x, v.y, e);
}

<# 
	}
} 
#>

