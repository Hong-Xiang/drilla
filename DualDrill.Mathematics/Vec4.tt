<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var rank = 4;
   string[] tName = ["i", "u", "f"];
   string[] types16 = ["short", "ushort", "Half"];
   string[] types32 = ["int", "uint", "float"];
   string[] types64 = ["long", "ulong", "double"];

   (int, string[])[] types = [(16, types16), (32, types32), (64, types64)];

   (int, string)[] cis = [(0, "x"), (1, "y"), (2, "z"), (3, "w")];
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static DualDrill.Mathematics.DMath;

namespace DualDrill.Mathematics;

<# foreach(var (bw, ts) in types) { #>
// <#= bw #>-bit scalar vec types
<#
	if(4 * bw < 64) {
		continue;
	}
	foreach(var (n, t) in tName.Zip(ts, (a, b) => (a, b))) 
	{
		
		if(bw == 16 && n == "f") {
			continue;
		}
		var name = $"vec{rank}{n}";
		var dataTypeName = $"Vector{4 * bw}";
		var stn = name + bw;
#>

public partial struct <#= name #><#= bw #> {
	internal <#= dataTypeName #><<#= t #>> Data;

	public <#= t #> x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public <#= t #> y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public <#= t #> z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public <#= t #> w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(Data[0], Data[1], Data[2], value);
		}
	}

	<# foreach((var i0, var c0) in cis.Take(rank)) { #>
<# foreach((var i1, var c1) in cis.Take(rank)) { #>
	public vec2<#= n #><#= bw #> <#= c0 #><#= c1 #> {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => vec2(<#= c0 #>, <#= c1 #>);

<# if (i0 != i1) { 
	    string[] comps = ["x", "y", "z", "w"];
		comps[i0] = "value.x";
		comps[i1] = "value.y";
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(<#= comps[0] #>, <#= comps[1] #>, <#= comps[2] #>, <#= comps[3] #>);
		}
<# } #>

	}
<# } #>
<# } #>

<# foreach((var i0, var c0) in cis.Take(rank)) { #>
<# foreach((var i1, var c1) in cis.Take(rank)) { #>
<# foreach((var i2, var c2) in cis.Take(rank)) { #>
	public vec3<#= n #><#= bw #> <#= c0 #><#= c1 #><#= c2 #> {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => vec3(<#= c0 #>, <#= c1 #>, <#= c2 #>);

<# if (i0 != i1 && i0 != i2 && i1 != i2) { 
	    string[] comps = ["x", "y", "z", "w"];
		comps[i0] = "value.x";
		comps[i1] = "value.y";
		comps[i2] = "value.z";
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = <#= dataTypeName #>.Create(<#= comps[0] #>, <#= comps[1] #>, <#= comps[2] #>, <#= comps[3] #>);
		}
<# } #>
      }

<# } #>
<# } #>
<# } #>

<# foreach((_, var c0) in cis.Take(rank)) { #>
<# foreach((_, var c1) in cis.Take(rank)) { #>
<# foreach((_, var c2) in cis.Take(rank)) { #>
<# foreach((_, var c3) in cis.Take(rank)) { #>
	public vec4<#= n #><#= bw #> <#= c0 #><#= c1 #><#= c2 #><#= c3 #> {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => vec4(<#= c0 #>, <#= c1 #>, <#= c2 #>, <#= c3 #>);
	}
<# } #>
<# } #>
<# } #>
<# } #>


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator -(<#= stn #> v) => new() { Data = - v.Data };

<# foreach(var op in (string [])[ "+", "-", "*", "/", "&", "|", "^" ]) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator <#= op #> (<#= stn #> l, <#= stn #> r) => new() { Data = l.Data <#= op #> r.Data };

<# } #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= stn #> operator %(<#= stn #> l, <#= stn #> r) => new() { Data = <#= dataTypeName #>.Create((<#= t #>)(l.x % r.x), (<#= t #>)(l.y % r.y), (<#= t #>)(l.z % r.z), default(<#= t #>)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(<#= t #> x, <#= t #> y, <#= t #> z, <#= t #> w) => new() { Data =  <#= dataTypeName #>.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(<#= t #> e) => new () { Data = <#= dataTypeName #>.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(<#= t #> x, <#= t #> y, vec2<#= n #><#= bw #> v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(<#= t #> x, vec2<#= n #><#= bw #> v, <#= t #> w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(vec2<#= n #><#= bw #> v, <#= t #> z, <#= t #> w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(<#= t #> e, vec3<#= n #><#= bw #> v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static <#= name #><#= bw #> vec4(vec3<#= n #><#= bw #> v, <#= t #> e) => vec4(v.x, v.y, v.z, e);
}

<# 
	}
} 
#>

