







//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static DualDrill.Mathematics.DMath;

namespace DualDrill.Mathematics;


// 16-bit scalar vec types


public partial struct vec4i16 {
	internal Vector64<short> Data;

	public short x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public short y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public short z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public short w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator -(vec4i16 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator + (vec4i16 l, vec4i16 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator - (vec4i16 l, vec4i16 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator * (vec4i16 l, vec4i16 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator / (vec4i16 l, vec4i16 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator & (vec4i16 l, vec4i16 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator | (vec4i16 l, vec4i16 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator ^ (vec4i16 l, vec4i16 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 operator %(vec4i16 l, vec4i16 r) => new() { Data = Vector64.Create((short)(l.x % r.x), (short)(l.y % r.y), (short)(l.z % r.z), default(short)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(short x, short y, short z, short w) => new() { Data =  Vector64.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(short e) => new () { Data = Vector64.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(short x, short y, vec2i16 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(short x, vec2i16 v, short w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(vec2i16 v, short z, short w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(short e, vec3i16 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i16 vec4(vec3i16 v, short e) => vec4(v.x, v.y, v.z, e);
}



public partial struct vec4u16 {
	internal Vector64<ushort> Data;

	public ushort x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public ushort y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public ushort z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public ushort w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector64.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator -(vec4u16 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator + (vec4u16 l, vec4u16 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator - (vec4u16 l, vec4u16 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator * (vec4u16 l, vec4u16 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator / (vec4u16 l, vec4u16 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator & (vec4u16 l, vec4u16 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator | (vec4u16 l, vec4u16 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator ^ (vec4u16 l, vec4u16 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 operator %(vec4u16 l, vec4u16 r) => new() { Data = Vector64.Create((ushort)(l.x % r.x), (ushort)(l.y % r.y), (ushort)(l.z % r.z), default(ushort)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(ushort x, ushort y, ushort z, ushort w) => new() { Data =  Vector64.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(ushort e) => new () { Data = Vector64.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(ushort x, ushort y, vec2u16 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(ushort x, vec2u16 v, ushort w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(vec2u16 v, ushort z, ushort w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(ushort e, vec3u16 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u16 vec4(vec3u16 v, ushort e) => vec4(v.x, v.y, v.z, e);
}


// 32-bit scalar vec types


public partial struct vec4i32 {
	internal Vector128<int> Data;

	public int x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public int y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public int z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public int w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator -(vec4i32 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator + (vec4i32 l, vec4i32 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator - (vec4i32 l, vec4i32 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator * (vec4i32 l, vec4i32 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator / (vec4i32 l, vec4i32 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator & (vec4i32 l, vec4i32 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator | (vec4i32 l, vec4i32 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator ^ (vec4i32 l, vec4i32 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 operator %(vec4i32 l, vec4i32 r) => new() { Data = Vector128.Create((int)(l.x % r.x), (int)(l.y % r.y), (int)(l.z % r.z), default(int)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(int x, int y, int z, int w) => new() { Data =  Vector128.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(int e) => new () { Data = Vector128.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(int x, int y, vec2i32 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(int x, vec2i32 v, int w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(vec2i32 v, int z, int w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(int e, vec3i32 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i32 vec4(vec3i32 v, int e) => vec4(v.x, v.y, v.z, e);
}



public partial struct vec4u32 {
	internal Vector128<uint> Data;

	public uint x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public uint y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public uint z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public uint w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator -(vec4u32 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator + (vec4u32 l, vec4u32 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator - (vec4u32 l, vec4u32 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator * (vec4u32 l, vec4u32 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator / (vec4u32 l, vec4u32 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator & (vec4u32 l, vec4u32 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator | (vec4u32 l, vec4u32 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator ^ (vec4u32 l, vec4u32 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 operator %(vec4u32 l, vec4u32 r) => new() { Data = Vector128.Create((uint)(l.x % r.x), (uint)(l.y % r.y), (uint)(l.z % r.z), default(uint)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(uint x, uint y, uint z, uint w) => new() { Data =  Vector128.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(uint e) => new () { Data = Vector128.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(uint x, uint y, vec2u32 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(uint x, vec2u32 v, uint w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(vec2u32 v, uint z, uint w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(uint e, vec3u32 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u32 vec4(vec3u32 v, uint e) => vec4(v.x, v.y, v.z, e);
}



public partial struct vec4f32 {
	internal Vector128<float> Data;

	public float x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public float y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public float z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public float w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector128.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator -(vec4f32 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator + (vec4f32 l, vec4f32 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator - (vec4f32 l, vec4f32 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator * (vec4f32 l, vec4f32 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator / (vec4f32 l, vec4f32 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator & (vec4f32 l, vec4f32 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator | (vec4f32 l, vec4f32 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator ^ (vec4f32 l, vec4f32 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 operator %(vec4f32 l, vec4f32 r) => new() { Data = Vector128.Create((float)(l.x % r.x), (float)(l.y % r.y), (float)(l.z % r.z), default(float)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(float x, float y, float z, float w) => new() { Data =  Vector128.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(float e) => new () { Data = Vector128.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(float x, float y, vec2f32 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(float x, vec2f32 v, float w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(vec2f32 v, float z, float w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(float e, vec3f32 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f32 vec4(vec3f32 v, float e) => vec4(v.x, v.y, v.z, e);
}


// 64-bit scalar vec types


public partial struct vec4i64 {
	internal Vector256<long> Data;

	public long x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public long y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public long z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public long w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator -(vec4i64 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator + (vec4i64 l, vec4i64 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator - (vec4i64 l, vec4i64 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator * (vec4i64 l, vec4i64 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator / (vec4i64 l, vec4i64 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator & (vec4i64 l, vec4i64 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator | (vec4i64 l, vec4i64 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator ^ (vec4i64 l, vec4i64 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 operator %(vec4i64 l, vec4i64 r) => new() { Data = Vector256.Create((long)(l.x % r.x), (long)(l.y % r.y), (long)(l.z % r.z), default(long)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(long x, long y, long z, long w) => new() { Data =  Vector256.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(long e) => new () { Data = Vector256.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(long x, long y, vec2i64 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(long x, vec2i64 v, long w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(vec2i64 v, long z, long w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(long e, vec3i64 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4i64 vec4(vec3i64 v, long e) => vec4(v.x, v.y, v.z, e);
}



public partial struct vec4u64 {
	internal Vector256<ulong> Data;

	public ulong x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public ulong y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public ulong z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public ulong w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator -(vec4u64 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator + (vec4u64 l, vec4u64 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator - (vec4u64 l, vec4u64 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator * (vec4u64 l, vec4u64 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator / (vec4u64 l, vec4u64 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator & (vec4u64 l, vec4u64 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator | (vec4u64 l, vec4u64 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator ^ (vec4u64 l, vec4u64 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 operator %(vec4u64 l, vec4u64 r) => new() { Data = Vector256.Create((ulong)(l.x % r.x), (ulong)(l.y % r.y), (ulong)(l.z % r.z), default(ulong)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(ulong x, ulong y, ulong z, ulong w) => new() { Data =  Vector256.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(ulong e) => new () { Data = Vector256.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(ulong x, ulong y, vec2u64 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(ulong x, vec2u64 v, ulong w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(vec2u64 v, ulong z, ulong w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(ulong e, vec3u64 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4u64 vec4(vec3u64 v, ulong e) => vec4(v.x, v.y, v.z, e);
}



public partial struct vec4f64 {
	internal Vector256<double> Data;

	public double x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(value, Data[1], Data[2], Data[3]);
		}
	}
	public double y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], value, Data[2], Data[3]);
		}
	}
	public double z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], value, Data[3]);
		}
	}
	public double w {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[3];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = Vector256.Create(Data[0], Data[1], Data[2], value);
		}
	}
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator -(vec4f64 v) => new() { Data = - v.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator + (vec4f64 l, vec4f64 r) => new() { Data = l.Data + r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator - (vec4f64 l, vec4f64 r) => new() { Data = l.Data - r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator * (vec4f64 l, vec4f64 r) => new() { Data = l.Data * r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator / (vec4f64 l, vec4f64 r) => new() { Data = l.Data / r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator & (vec4f64 l, vec4f64 r) => new() { Data = l.Data & r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator | (vec4f64 l, vec4f64 r) => new() { Data = l.Data | r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator ^ (vec4f64 l, vec4f64 r) => new() { Data = l.Data ^ r.Data };


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 operator %(vec4f64 l, vec4f64 r) => new() { Data = Vector256.Create((double)(l.x % r.x), (double)(l.y % r.y), (double)(l.z % r.z), default(double)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(double x, double y, double z, double w) => new() { Data =  Vector256.Create(x, y, z, w) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(double e) => new () { Data = Vector256.Create(e) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(double x, double y, vec2f64 v) => vec4(x, y, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(double x, vec2f64 v, double w) => vec4(x, v.x, v.y, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(vec2f64 v, double z, double w) => vec4(v.x, v.y, z, w);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(double e, vec3f64 v) => vec4(e, v.x, v.y, v.z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec4f64 vec4(vec3f64 v, double e) => vec4(v.x, v.y, v.z, e);
}



