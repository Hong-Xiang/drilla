//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static DualDrill.Mathematics.DMath;

namespace DualDrill.Mathematics;

// 16-bit scalar vec types

public partial struct vec3i16 {
	internal Vector64<short> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector64<short> CreateData(short x, short y, short z) {
		return Vector64.Create(x, y, z, default(short));
	}

	public short x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public short y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public short z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator -(vec3i16 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator + (vec3i16 l, vec3i16 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator - (vec3i16 l, vec3i16 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator * (vec3i16 l, vec3i16 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator / (vec3i16 l, vec3i16 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator & (vec3i16 l, vec3i16 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator | (vec3i16 l, vec3i16 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator ^ (vec3i16 l, vec3i16 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 operator %(vec3i16 l, vec3i16 r) => new() { Data = Vector64.Create((short)(l.x % r.x), (short)(l.y % r.y), (short)(l.z % r.z), default(short)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 vec3(short x, short y, short z) => new() { Data =  vec3i16.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 vec3(short e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 vec3(short e, vec2i16 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i16 vec3(vec2i16 v, short e) => vec3(v.x, v.y, e);
}


public partial struct vec3u16 {
	internal Vector64<ushort> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector64<ushort> CreateData(ushort x, ushort y, ushort z) {
		return Vector64.Create(x, y, z, default(ushort));
	}

	public ushort x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public ushort y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public ushort z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator -(vec3u16 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator + (vec3u16 l, vec3u16 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator - (vec3u16 l, vec3u16 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator * (vec3u16 l, vec3u16 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator / (vec3u16 l, vec3u16 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator & (vec3u16 l, vec3u16 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator | (vec3u16 l, vec3u16 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator ^ (vec3u16 l, vec3u16 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 operator %(vec3u16 l, vec3u16 r) => new() { Data = Vector64.Create((ushort)(l.x % r.x), (ushort)(l.y % r.y), (ushort)(l.z % r.z), default(ushort)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 vec3(ushort x, ushort y, ushort z) => new() { Data =  vec3u16.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 vec3(ushort e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 vec3(ushort e, vec2u16 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u16 vec3(vec2u16 v, ushort e) => vec3(v.x, v.y, e);
}

// 32-bit scalar vec types

public partial struct vec3i32 {
	internal Vector128<int> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector128<int> CreateData(int x, int y, int z) {
		return Vector128.Create(x, y, z, default(int));
	}

	public int x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public int y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public int z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator -(vec3i32 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator + (vec3i32 l, vec3i32 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator - (vec3i32 l, vec3i32 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator * (vec3i32 l, vec3i32 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator / (vec3i32 l, vec3i32 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator & (vec3i32 l, vec3i32 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator | (vec3i32 l, vec3i32 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator ^ (vec3i32 l, vec3i32 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 operator %(vec3i32 l, vec3i32 r) => new() { Data = Vector128.Create((int)(l.x % r.x), (int)(l.y % r.y), (int)(l.z % r.z), default(int)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 vec3(int x, int y, int z) => new() { Data =  vec3i32.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 vec3(int e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 vec3(int e, vec2i32 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i32 vec3(vec2i32 v, int e) => vec3(v.x, v.y, e);
}


public partial struct vec3u32 {
	internal Vector128<uint> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector128<uint> CreateData(uint x, uint y, uint z) {
		return Vector128.Create(x, y, z, default(uint));
	}

	public uint x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public uint y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public uint z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator -(vec3u32 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator + (vec3u32 l, vec3u32 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator - (vec3u32 l, vec3u32 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator * (vec3u32 l, vec3u32 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator / (vec3u32 l, vec3u32 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator & (vec3u32 l, vec3u32 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator | (vec3u32 l, vec3u32 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator ^ (vec3u32 l, vec3u32 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 operator %(vec3u32 l, vec3u32 r) => new() { Data = Vector128.Create((uint)(l.x % r.x), (uint)(l.y % r.y), (uint)(l.z % r.z), default(uint)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 vec3(uint x, uint y, uint z) => new() { Data =  vec3u32.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 vec3(uint e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 vec3(uint e, vec2u32 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u32 vec3(vec2u32 v, uint e) => vec3(v.x, v.y, e);
}


public partial struct vec3f32 {
	internal Vector128<float> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector128<float> CreateData(float x, float y, float z) {
		return Vector128.Create(x, y, z, default(float));
	}

	public float x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public float y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public float z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator -(vec3f32 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator + (vec3f32 l, vec3f32 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator - (vec3f32 l, vec3f32 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator * (vec3f32 l, vec3f32 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator / (vec3f32 l, vec3f32 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator & (vec3f32 l, vec3f32 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator | (vec3f32 l, vec3f32 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator ^ (vec3f32 l, vec3f32 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 operator %(vec3f32 l, vec3f32 r) => new() { Data = Vector128.Create((float)(l.x % r.x), (float)(l.y % r.y), (float)(l.z % r.z), default(float)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 vec3(float x, float y, float z) => new() { Data =  vec3f32.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 vec3(float e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 vec3(float e, vec2f32 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f32 vec3(vec2f32 v, float e) => vec3(v.x, v.y, e);
}

// 64-bit scalar vec types

public partial struct vec3i64 {
	internal Vector256<long> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector256<long> CreateData(long x, long y, long z) {
		return Vector256.Create(x, y, z, default(long));
	}

	public long x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public long y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public long z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator -(vec3i64 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator + (vec3i64 l, vec3i64 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator - (vec3i64 l, vec3i64 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator * (vec3i64 l, vec3i64 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator / (vec3i64 l, vec3i64 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator & (vec3i64 l, vec3i64 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator | (vec3i64 l, vec3i64 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator ^ (vec3i64 l, vec3i64 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 operator %(vec3i64 l, vec3i64 r) => new() { Data = Vector256.Create((long)(l.x % r.x), (long)(l.y % r.y), (long)(l.z % r.z), default(long)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 vec3(long x, long y, long z) => new() { Data =  vec3i64.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 vec3(long e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 vec3(long e, vec2i64 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3i64 vec3(vec2i64 v, long e) => vec3(v.x, v.y, e);
}


public partial struct vec3u64 {
	internal Vector256<ulong> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector256<ulong> CreateData(ulong x, ulong y, ulong z) {
		return Vector256.Create(x, y, z, default(ulong));
	}

	public ulong x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public ulong y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public ulong z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator -(vec3u64 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator + (vec3u64 l, vec3u64 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator - (vec3u64 l, vec3u64 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator * (vec3u64 l, vec3u64 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator / (vec3u64 l, vec3u64 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator & (vec3u64 l, vec3u64 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator | (vec3u64 l, vec3u64 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator ^ (vec3u64 l, vec3u64 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 operator %(vec3u64 l, vec3u64 r) => new() { Data = Vector256.Create((ulong)(l.x % r.x), (ulong)(l.y % r.y), (ulong)(l.z % r.z), default(ulong)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 vec3(ulong x, ulong y, ulong z) => new() { Data =  vec3u64.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 vec3(ulong e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 vec3(ulong e, vec2u64 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3u64 vec3(vec2u64 v, ulong e) => vec3(v.x, v.y, e);
}


public partial struct vec3f64 {
	internal Vector256<double> Data;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Vector256<double> CreateData(double x, double y, double z) {
		return Vector256.Create(x, y, z, default(double));
	}

	public double x {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[0];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(value, Data[1], Data[2]);
		}
	}
	public double y {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[1];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], value, Data[2]);
		}
	}
	public double z {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Data[2];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set {
			Data = CreateData(Data[0], Data[1], value);
		}
	}

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator -(vec3f64 v) => new() { Data = - v.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator + (vec3f64 l, vec3f64 r) => new() { Data = l.Data + r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator - (vec3f64 l, vec3f64 r) => new() { Data = l.Data - r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator * (vec3f64 l, vec3f64 r) => new() { Data = l.Data * r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator / (vec3f64 l, vec3f64 r) => new() { Data = l.Data / r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator & (vec3f64 l, vec3f64 r) => new() { Data = l.Data & r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator | (vec3f64 l, vec3f64 r) => new() { Data = l.Data | r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator ^ (vec3f64 l, vec3f64 r) => new() { Data = l.Data ^ r.Data };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 operator %(vec3f64 l, vec3f64 r) => new() { Data = Vector256.Create((double)(l.x % r.x), (double)(l.y % r.y), (double)(l.z % r.z), default(double)) };
} 

public partial class DMath {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 vec3(double x, double y, double z) => new() { Data =  vec3f64.CreateData(x, y, z) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 vec3(double e) => vec3(e, e, e);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 vec3(double e, vec2f64 v) => vec3(e, v.x, v.y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static vec3f64 vec3(vec2f64 v, double e) => vec3(v.x, v.y, e);
}


